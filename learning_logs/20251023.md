# Login Process 진행
# REST API 호출
현재 상황에서 로그인을 성공한다고 하더라도 jwt를 세션 스토리지에 저장했을 뿐이고, 아직 getCars()의 결과값을 가져오지는 못합니다. 그 이유는 기본적으로 Login 컴포넌트에서 얻은 토큰을 가지로 frontend 상에서 Carlist를 불러오지 못하고 있는 상황이기 때문입니다. carapi.ts에 getCars() 호출을 할 때 얻어온 jwt를 사용해야 하기 때문입니다. 근데 jwtToken 값이 생각해보면 .then()에 걸려있기 때문에 일종의 지역변수라고 볼 수 있겠습니다. 그렇다면 Login 컴포넌트를 벗어나서는 사용할 수 없다는 의미가 될 겁니다. 그러면 얘를 어떻게 끌고 와서 getCars() 함수에 jwt값을 넣어서 같이 GET요청을 보낼 수 있을지 생각해봐야합니다. carapi.ts에서 쓰려고 sessionStorage에 setItem을 했습니다.

```ts
import axios from "axios";
import { CarResponse, Car, CarEntity } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer ','');
    const response = await axios.get(
        `${import.meta.env.VITE_API_URL}/api/cars`,
        {headers: { 'Authorization': rawToken }}
    );

    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt')?.replace('Bearer ','');
    const response = await axios.delete(link, {
        headers: {
            'Authorization': token
        }
    });
    return response.data
}

export const addCar = async (car: Car) : Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer ','');
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, {
        headers: {
            'Authorization': rawToken
        },
    });

    return response.data;
}

export const updateCar = async(CarEntity: CarEntity): Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer ','');
    const response = await axios.put(CarEntity.url, CarEntity.car, {
        headers: {
            'Authorization': rawToken
        },
    });
    return response.data;
}
```
이상은 리팩토링 하기 전입니다. token을 세션 스토리지에서 불러오고, 여기서 Bearer 접두사를 제거하는 부분, 그리고 headers 내에 'Authorization' : token 부분이 중복되고 있습니다. 여기서 알아야 할점은 Scope 개념입니다. 각 함수의 내부에서 token을 선언하고 Bearer 접두사를 제거하고 있기 때문에 함수 마다 선언 및 초기화를 하는 것 같습니다.

## 중복 코드 리팩토링
```ts
import axios, { AxiosRequestConfig } from "axios";
import { CarResponse, Car, CarEntity } from "../types";

const getAxiosConfig = () : AxiosRequestConfig => {
    const token = sessionStorage.getItem('jwt')?.replace('Bearer ','');
    
    return {
        headers: {
            'Authorization': token,
            'Content-Type': 'application/json',
        }
    };
};

export const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(
        `${import.meta.env.VITE_API_URL}/api/cars`, getAxiosConfig())

    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const response = await axios.delete(link, getAxiosConfig());
    
    return response.data
}

export const addCar = async (car: Car) : Promise<CarResponse> => {
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, getAxiosConfig());

    return response.data;
}

export const updateCar = async(CarEntity: CarEntity): Promise<CarResponse> => {
    const response = await axios.put(CarEntity.url, CarEntity.car, getAxiosConfig());
    
    return response.data;
}
```
이상에서 고려할 점은 getAxiosConfig의 return 타입으로 사용된 AxiosRequestConfig입니다.
- AxiosRequestConfig : Axios 라이브러리에서 HTTP 요청을 만들 때 사용되는 구성 객체 타입 정의에 해당합니다. 즉, Axios를 경유하여 요청을 보내기 위해 필요한 _모든 옵션_ 을 담는 일종의 interface에 해당합니다.
- axios.post(), .get ...과 같은 방식으로 사용합니다. 이는 좀 더 가독성을 높이기 위한 방식으로 _메서드 별 요청_ 에 해당합니다. 이 경우 endpoint 다음에 두 번째 argument로 사용됩니다.
```ts
// GET 요청이라고 가정
// 1번
axios.get('http://localhost8080/api/cars',
{headers:{'Authorzation' : token}});

// 2번
axios({
  method: 'get',
  url: 'http://localhost8080/api/cars',
   {headers:{'Authorzation' : token}});
})
```
이상의 2가지 과정 중에 return 타입에 객체 형태로 옵션들을 담을 수 있는 것을 AxiosRequestConfig라고 합니다. 현재 1번 방법을 사용했기 때문에 getAxiosConfig() 함수의 정의가 간단한 편에 속했습니다. 2번 방법이면 method 키의 value를 지정하는게 복잡했을 겁니다.

인터셉터(interceptor)에서의 활용 : request interceptor는 요청이 서버로 가기 전에 가로채서 구성을 수정합니다. 즉 getAxiosConfig() 함수 요청을 하게 되면 처음에는 token이 없는 상태로 DB까지 가게 될 뻔했는데, 얘가 중간에 가로채서 headers를 추가해준다는 의미가 됩니다.

## Authentication 실패 시 오류 메시지를 토스트 메시지로 전환
```tsx
<Snackbar
  open={open}
  autoHideDuration={3000}
  onClose={() => setOpen(false)}
  message='ID 혹은 비밀번호가 틀렸습니다...⛔'
/>
```
라고 설정을 했다고 가정했을 때, 우리는 setOpen(true)를 호출하는 부분이 필요할 것 같습니다. Login 컴포넌트 중 어떤 동작을 했을 때 toast message가 출력되어야 하며, 그래서 setOpen(true) 코드를 삽입해야 할 부분을 생각해봐야합니다.








