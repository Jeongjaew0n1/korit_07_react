## 리액트 폼 처리
HTML 양식은 제출되면 다음 페이지로 이동하지만, React에서는 제출 후 폼 데이터에 접근할 수 있는 JS 함수를 호출하고 다음 페이지로의 이동을 방지하고 싶은 경우가 흔히 있습니다.(SPA니까) .preventDefault()를 이용하여 제출 자체를 피하는 방법도 있습니다.
```jsx
import { useState } from "react";

function MyForm() {
  const [ text, setText ] = useState('');

  // input field에 입력한 것을 submit하면 날려보낼 수 있도록 하는 함수를 작성
  const handleSubmit = (event) => {
    alert(`'${text}' 라고 입력하였습니다.`);
    event.preventDefault();
  }
  const handleChange = (event) => {
    setText(event.target.value);
    console.log(text);
  }

  return(
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" onChange={event => setText(event.target.value)} value={text}/>
        <br />
        <br />
        <input type="submit" value='클릭하세요'/>
      </form>
    </>
  );
}
export default MyForm;
```

입력 폼에 입력 필드가 복수로 이루어져있습니다. 그러면 각각의 상태를 선언하는 방법도 있겠지만, 객체를 이용하여 처리하는 방법도 있습니다.
```jsx
import { useState } from "react";

function MyForm3() {

  const [ user, setUser ] = useState({
    firstName: '',
    lastName: '',
    email: ''
  });
  
  // form에서 쓸거라 handleSubmit부터 작성하겠습니다.
  const handleSubmit = (event) => {
    alert(`Hello, ${user.firstName} ${user.lastName}`);
    event.preventDefault();
  }

  // form 태그 썻고 내부에 input 창으로 입력 받을거니까 onChange를 작성할겁니다.
  const handleChange = (event) => {
    setUser({...user, [event.target.name]: [event.target.value]});
  }

  return(
    <form onSubmit={handleSubmit}>
      <label>First Name : </label>
      <input type="text" name='firstName' onChange={handleChange} value={user.firstName}/>
      <br />
      <label>Last Name : </label>
      <input type="text" name='lastName' onChange={handleChange} value={user.lastName}/>
      <br />
      <label>Email : </label>
      <input type="text" name='email' onChange={handleChange} value={user.email}/>
      <br />
      <input type="submit" value='클릭하세요'/>
      <br /> <br />
    </form>
  );
}
export default MyForm3;
```

# TypeScript
- TypeScript는 MS에서 개발한 타입 시스템을 제공하는 JS 상위 집합에 해당합니다.
- 특징
1. 변수, 함수, 클래스에 대한 _자료형_ 을 정의할 수 있다. 이를 통해 개발 프로세스 초기에 오류로 포착하는 것이 가능.
2. 앱의 확장성을 향상시킬 수도 있고, 코드를 더 쉽게 유지 관리할 수 있게 해줌.
3. 코드 가독성이 향상되고 코드 자체 문서화가 더 쉽다.

 * 참조 : 타입스크립트 작성용 웹 IDE 사이트 : https://www.typescriptlang.org/

## 공통 타입
TS는 변수를 초기화할 때 변수의 타입을 자동으로 정의하는데, 이를 _타입 추론_ 이라고 함. TS의 기본 타입은 JS와 동일합니다. JS가 매번 암시적으로 타입 추론을 하게끔 하는 것이 아니라, 명시적으로 타입 설정을 하는 것도 가능합니다.

massage에 string 값을 대입했을 때, ts는 해당 변수의 자료형이 string이라고 알아서 타입 추론을 합니다. 그런데 다음 줄에서 message 변수에 number 자료형을 대입하니까 오류가 뜹니다.(JS에서는 상관 없습니다)
```ts
let message = '안녕하세요';
message = 1; // Errors in code : Type 'number' is not assignable to type 'string'.
```

명시적 타입 설정 방법
```ts
let email: string;
email = 3; // Errors in code : Type 'number' is not assignable to type 'string'.
// 이상에서의 주목해야 할 점은 email이 number 자료형으로 초기화가  됐음에도 불구하고 오류가 발생
let age: number;
let isActive: boolean;
```

변수의 자료형 확인
```ts
let email: string;
let age: number;
let isActive: boolean;

email = 'a@test.com';
age = 0;

// 변수의 자료형 확인
console.log(typeof email); // 결과값 : "string"
console.log(typeof age === "string"); // 결과값 : false
```

변수의 타입을 모르는 경우도 있을 수 있습니다. 예를 들어서 외부 소스로부터 값을 받아올 경우엔 명확한 자료형을 모를 수도 있습니다.
```ts
let externalValue: unknown;
```
* 참조 : TS에소는 any라는 자료형이 있습니다. any 타입을 이용하여 변수를 정의하는 경우는 TS가 해당 변수에 대해 타입 검사 또는 추론을 아예 하지 않습니다(즉, 기존의 JS처럼 사용이 가능합니다). 근데 이건 TS를 사용하지 않겠다고 하는 거랑 똑같다 보니 가능한 any는 쓰지 않는 것을 추천합니다.

- 배열 Array : JS에서와 동일한 방식으로 선언할 수 있기는 하지만, 배열의 element들의 자료형을 정의해야 합니다.
```ts
let arrayOfNums: number[] = [1,2,3,4,5];
let animals: string[] = ['Dog','Cat','Tiger'];

// 제네릭 타입을 사용하는 방법
let arrayOfNums2: Array<number> = [9,8,7,6];
let animals2: Array<string> = ['개','고양이','호랑이'];
```

- 객체 Object에서도 각각의 property에 대해 타입 추론을 알아서 합니다.
```ts
const student = {
  id : 1,
  name : '김일',
  email : 'kim1@test.com'
}
```
라고 했을 때, 자료형을 미리 통제하고 싶다면 interface / type 키워드를 활용하여 객체 내부의 property의 자료형을 명시하는 것이 가능합니다.
```ts
// interface 이용 사례
interface Student {
    id: number;
    name: string;
    email: string;
};

// Type 이용 사례
type Student2 = {
    id: number;
    name: string;
    email: string;
};

// 이상과 같이 Student의 속성에 대한 자료형이 있다고 가정했을 때, 이를 다 모아둔 Student를 자료형으로 또 쓸 수 있습니다.
const myStudent: Student = {
    id: 1, // id: '1',, 로 쓰면 오류 발생
    name: '김일',
    email: 'kim1@test.com'
};
```

Java에서의 와일드 카드에 해당하는 `?`도 있습니다. 선택적 속성을 정의할 수 있는데, 이는 일종의 생성자 부분과 관련이 있다고 볼 수 있습니다.
```ts
type Student2 = {
    id: number;
    name: string;
    email?: string;
};

const myStudent: Student2 = {
    id: 1,
    name: '김일',
};

console.log(myStudent.email); // 결과값 : undefined
```

- 선택적 체이닝 연산자(?.)를 이용하면 오류를 일으키지 않고 null이거나 undefined일 수 있는 객체 속성 및 메서드에 안전하게 접근이 가능.
```ts
type Person = {
  name: string;
  email: string;
  address?: {
    street: string;
    city: string;
  }
}

// 객체 생성
const person: Person = {
    name: '김이',
    email: 'kim@test.com'
}

console.log(person);
// console.log(person.address.street); 오류 발생
console.log(person.address?.street); // 선택적 체이닝을 통해 오류 발생 자체를 억제할 수 있습니다. 결과값 : undefined
```

TS를 적용했을 때의 이점은 기본적으로 JS상에서는 _실행을 시키고 오류 유무를 확인 가능_ 했지만, TS상에서는 개발단계에서 예측 가능한 오류를 발생시키지 않을 수 있다는 점입니다.

- 연산자를 이용한 서로 다른 타입을 병렬로 명시하는 방법
```ts
type InputType = string | number;
// 정의한 타입을 이용
let name1: InputType = 'Hello';
let age: InputType = 12;
```

연산자를 이용해서 _서로 다른 타입을 처리하는 타입_ 인 유니언 타입(Union Type)을 만드는 것이 가능합니다. 일종의 사용자 정의 type이라고 볼 수 있겠습니다. Java에서 class를 정의한 방식이랑 비슷합니다. 매개변수의 자료형을 고정시키거나 혹은 복수의 자료형 중에 하나를 선택할 수 있게끔 하는 방식입니다.
```ts
type Fuel = 'disel' | 'gasolin' | 'electronic';
type NoOfGears = 5 | 6 | 7;

type Car = {
  brand: string,
  fuel: Fuel,
  gear: NoOfGears;
};

const car1: Car = {
  brand: '기아',
  fuel: 'disel',
  gear: 5
}
const car2: Car = {
  brand: '기아',
  fuel: 'disell', // 오타가 나거나 Fuel 내에 있는 string data를 벗어나면 오류
  gear: 5
}
```

## 함수
```ts
function sayHello(name: string) {
  console.log('Hello ' + name);
}

// name의 자료형을 다른 것도 추가하려면 OR 연산자 사용
function sayHello(name: string | number) {
  console.log('Hello ' + name);
}

sayHello(1);
sayHello('김일');
```

return 타입에 대한 자료형 통계 부분입니다.
```ts
function calcSum(x: number, y: number): number {
  return x + y;
}
```

## TypeScript in React
### 상태와 프롭
- 리액트에서는 컴포넌트 프롭의 타입을 정의해야 합니다. 컴포넌트의 프롭이 JS 객체라고 학습을 했었습니다. 그래서 props.username과 같은 방식으로 호출했었죠. 그러면 프롭의 타입을 정의하기 위해서는 type 또는 interface를 사용하는 것이 가능할겁니다.

1. 객체 구조 분해
2. props drilling
3. props가 JS의 객체라는 점
4. typescript 상에서의 매개변수에 자료형을 통제하는 방법
```tsx
type HelloProps = {
  name: string;
  age: number;
}

function HelloComponent({name, age}: HelloProps) {

  return (
    <>
      Hello, {name}. you are {age} years old.
    </>
  )
}

export default HelloComponent;
```
이상의 코드에서 age='20'와 같은 방식으로 프롭을 전달하게 된다면 오류가 발생합니다. jsx의 경우 오류 메시지 자체가 나타나지 않습니다. 그럼 이 오류가 드러나는 시점은 age='20'이라는 string data를 가지고 수학 연산을 시도했을 시점이 되야 오류를 확인할 수 있게 됩니다.

하지만 TS를 사용했을 경우 미리 경고 메시지를 보여주기 때문에 연산 이전에 수정을 할 수 있다는 이점이 있습니다.

이미 정의한 type을 types/types.ts로 분할하여 import한 예시입니다.
```tsx
import HelloProps from "./types/types.ts";

function HelloComponent({name, age}: HelloProps) {

  return (
    <>
      Hello, {name}. you are {age} years old.
    </>
  )
}

export default HelloComponent;
```

 여기서 만약에 ByeComponent를 만든다고 가정했을 때, 거기서도 똑같이 ByeProps를 쓸 수 있겠죠. 근데 이 타입추론이라는 개념이 꼭 TS에서만 사용되는 것이 아니고 표준 리액트 타입인 FC(Function Component)가 있긴 합니다.
 ```jsx
import React from 'react';
import {HelloProps} from './types/types';

const HelloComponent : React.FC<HelloProps> = ({name, age}) => {
  return(
    <>
      Hello, {name}. you are {age} years old.
    </>
  );
}
 ```

useState 훅을 생각해보면 initialValue 값을 _타입 추론_ 한다는 것을 알 수 있습니다.
```jsx
// boolean
const [ isReady, setIsReady ] = useState(false);

// string
const [ message, setMessage ] = useState('');

// number
const [ count, setCount ] = useState(0);
```

그래서 암시적으로 작성된 type과 다른 자료형을 argument로 넣을 경우 오류가 발생합니다.
```jsx
setCount('Hello');
```

그런데 TS는 명시적으로 타입을 설정하는 편이기 때문에 useState()의 initialValue의 자료형을 통제하는 것이 가능합니다.
```tsx
const [ message, setMessage ] = useState<string | undefined>(undefined);
```

type / interface를 사용하는 방법도 있습니다.
```ts
// types.ts
type User = {
  id: number;
  name: string;
  email: string;
}
```
```tsx
import { User } from './types/types';
import { useState } from 'react';

function ExampleComponent() {
  // 타입을 상태와 함께 활용하고자 할 때 초기값으로는 아무것도 담겨있지 않은 User 객체를 이용
  const [ user, setUser] = useState<User>({} as User) // const [ user, setUser ] = useState<User | null>(null); null 값도 허용 가능.

  return (<></>);
}
export default ExampleComponent;
```

### 이벤트
TS를 이용할 때는 이벤트 타입을 세분화할 필요가 있습니다.

```tsx
<input
  type = 'text'
  onChange={handleChange}
  value={name}
>
```
```tsx
const handleChange = (event) => {
  setName{event.target.value};
}
```
handleSubmit 때도 매개변수를 event라고 정해줬었습니다.

event가 특정한 HTML element와 관련이 있다는 점을 명시할 때 사용하는 명령어가 있습니다.
```tsx
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setName{event.target.value};
}
```
form과 관련있는 onSubmit 이벤트 핸들러
```tsx
const handleSumbit = (event: React.FormEvent<HTMLFormElement>) => {
  enevt.preventDefault();
  alert(`Hello ${name}`);
}
```
와 같은 방식으로 작성합니다. 즉 저희가 임의적으로 e 혹은 매개변수 명을 짓기는 하지만, 어느 HTML 요소와 관련있는지에 따라 딸려있는 속성과 메서드가 서로 다르기 때문에, TS상에서는 이를 통제하는 편입니다.

## TS로 리액트 앱 만들기